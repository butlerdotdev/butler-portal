/*
 * Copyright 2026 The Butler Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { PipelineConfig } from './pipelineGenerator';

/**
 * Generates a GitLab CI YAML configuration string for a BYOC Terraform run.
 *
 * Uses the official HashiCorp Terraform Docker image. Secret env vars
 * are referenced using the $CI_VARIABLE syntax (GitLab CI/CD variables).
 * Includes a pre-flight status check to abort cancelled runs and posts
 * results back to the Butler callback URL.
 */
export function generateGitLabCiConfig(config: PipelineConfig): string {
  const {
    runId,
    callbackBaseUrl,
    operation,
    tfVersion,
    workingDirectory,
    envVars,
  } = config;

  const workDir = workingDirectory || '.';
  const callbackUrl = callbackBaseUrl.replace(/\/+$/, '');

  // Build variables block
  const variablesBlock = buildVariablesBlock(runId, envVars);

  // Build operation-specific terraform command
  const tfCommand = buildTerraformCommand(operation, workDir);

  // Build plan-specific after_script additions
  const planCapture = operation === 'plan' ? buildPlanCapture(workDir) : '';

  return `# Auto-generated by Butler Registry — do not edit
stages:
  - run

butler-${operation}:
  stage: run
  image:
    name: hashicorp/terraform:${tfVersion}
    entrypoint: [""]
${variablesBlock}
  before_script:
    # ── Pre-flight: check if run is cancelled ──────────────────────
    - |
      apk add --no-cache curl jq >/dev/null 2>&1 || true
      STATUS=$(curl -sf -H "Authorization: Bearer $BUTLER_CALLBACK_TOKEN" \\
        "${callbackUrl}/v1/runs/${runId}" | jq -r '.status // empty')
      if [ "$STATUS" = "cancelled" ]; then
        echo "ERROR: Run ${runId} has been cancelled — aborting."
        exit 1
      fi
      echo "Run status: $STATUS — proceeding."
    # ── Terraform Init ─────────────────────────────────────────────
    - cd ${workDir}
    - terraform init -input=false -no-color

  script:
    - cd ${workDir}
    - |
      set +e
      ${tfCommand} 2>&1 | tee /tmp/tf-output.log
      TF_EXIT=$?
      echo "$TF_EXIT" > /tmp/tf-exit-code
${planCapture}      exit 0

  after_script:
    # ── POST status update ─────────────────────────────────────────
    - |
      apk add --no-cache curl jq >/dev/null 2>&1 || true
      TF_EXIT=$(cat /tmp/tf-exit-code 2>/dev/null || echo "1")
      if [ "$TF_EXIT" = "0" ]; then
        RESULT_STATUS="succeeded"
      else
        RESULT_STATUS="failed"
      fi

      PAYLOAD=$(jq -n \\
        --arg status "$RESULT_STATUS" \\
        --arg exitCode "$TF_EXIT" \\
        --arg operation "${operation}" \\
        '{status: $status, exit_code: ($exitCode | tonumber), operation: $operation}')

${buildPlanJsonUpload(operation, callbackUrl, runId)}      curl -sf -X POST \\
        -H "Authorization: Bearer $BUTLER_CALLBACK_TOKEN" \\
        -H "Content-Type: application/json" \\
        -d "$PAYLOAD" \\
        "${callbackUrl}/v1/runs/${runId}/status"

    # ── POST logs ──────────────────────────────────────────────────
    - |
      if [ -f /tmp/tf-output.log ]; then
        LOG_B64=$(base64 -w0 /tmp/tf-output.log 2>/dev/null || base64 /tmp/tf-output.log)
        curl -sf -X POST \\
          -H "Authorization: Bearer $BUTLER_CALLBACK_TOKEN" \\
          -H "Content-Type: application/json" \\
          -d "$(jq -n --arg log "$LOG_B64" '{log: $log, encoding: \\"base64\\"}')" \\
          "${callbackUrl}/v1/runs/${runId}/logs"
      fi
`;
}

/**
 * Builds the GitLab CI variables block from envVars configuration.
 *
 * Secret-source vars use $CI_VARIABLE syntax (referencing GitLab CI/CD variables).
 * Literal values are injected directly.
 */
function buildVariablesBlock(
  runId: string,
  envVars?: Record<string, { source: string; ref?: string; key?: string; value?: string }>,
): string {
  const lines: string[] = ['  variables:', `    BUTLER_RUN_ID: "${runId}"`];

  if (envVars) {
    for (const [varName, varConfig] of Object.entries(envVars)) {
      if (varConfig.source === 'secret') {
        // Reference GitLab CI/CD variable (K8s Secret pattern)
        const ciVarName = varConfig.key || varName;
        lines.push(`    ${varName}: "$${ciVarName}"`);
      } else if (varConfig.source === 'ci_secret') {
        // CI-native secret reference
        const ciVarName = (varConfig as any).name || varName;
        lines.push(`    ${varName}: "$${ciVarName}"`);
      } else if (varConfig.source === 'literal' && varConfig.value !== undefined) {
        lines.push(`    ${varName}: "${escapeYamlString(varConfig.value)}"`);
      }
    }
  }

  return lines.join('\n');
}

/**
 * Builds the terraform command string based on operation type.
 */
function buildTerraformCommand(operation: string, _workDir: string): string {
  switch (operation) {
    case 'plan':
      return 'terraform plan -input=false -no-color -out=tfplan -json';
    case 'apply':
      return 'terraform apply -input=false -no-color -auto-approve tfplan';
    case 'validate':
      return 'terraform validate -no-color -json';
    case 'test':
      return 'terraform test -no-color -json';
    case 'destroy':
      return 'terraform destroy -input=false -no-color -auto-approve';
    default:
      return `terraform ${operation} -input=false -no-color`;
  }
}

/**
 * For plan operations, adds commands to capture the plan JSON.
 */
function buildPlanCapture(workDir: string): string {
  return `      # Capture plan JSON for callback
      if [ -f ${workDir}/tfplan ]; then
        cd ${workDir}
        terraform show -json tfplan > /tmp/tf-plan.json 2>/dev/null
      fi
`;
}

/**
 * For plan operations, adds after_script commands to upload plan JSON.
 */
function buildPlanJsonUpload(
  operation: string,
  _callbackUrl: string,
  _runId: string,
): string {
  if (operation !== 'plan') {
    return '';
  }

  return `      # Attach plan JSON if available
      if [ -f /tmp/tf-plan.json ]; then
        PLAN_B64=$(base64 -w0 /tmp/tf-plan.json 2>/dev/null || base64 /tmp/tf-plan.json)
        PAYLOAD=$(echo "$PAYLOAD" | jq --arg plan "$PLAN_B64" '. + {plan_json: $plan, plan_encoding: "base64"}')
      fi

`;
}

/**
 * Escapes special characters for safe YAML string embedding.
 */
function escapeYamlString(s: string): string {
  return s
    .replace(/\\/g, '\\\\')
    .replace(/"/g, '\\"')
    .replace(/\n/g, '\\n');
}
