/*
 * Copyright 2026 The Butler Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { PipelineConfig } from './pipelineGenerator';

// SHA-pinned action versions for supply chain security
const ACTIONS_CHECKOUT_SHA = '11bd71901bbe5b1630ceea73d27597364c9af683'; // v4.2.2
const SETUP_TERRAFORM_SHA = 'b9cd54a3c349d3f38e8881555d616ced269571ae'; // v3.1.2

/**
 * Generates a GitHub Actions workflow YAML string for a BYOC Terraform run.
 *
 * All action references are SHA-pinned to prevent supply chain attacks.
 * The workflow includes a pre-flight status check to abort cancelled runs,
 * captures operation output, and posts results back to the Butler callback URL.
 */
export function generateGitHubActionsWorkflow(config: PipelineConfig): string {
  const {
    runId,
    callbackBaseUrl,
    operation,
    tfVersion,
    repositoryUrl,
    version,
    workingDirectory,
    envVars,
  } = config;

  const workDir = workingDirectory || '.';
  const callbackUrl = callbackBaseUrl.replace(/\/+$/, '');

  // Build the env block for the job
  const envLines = buildEnvBlock(envVars);

  // Build operation-specific terraform command and post-operation steps
  const { tfCommand, postSteps } = buildTerraformCommand(operation, workDir);

  return `# Auto-generated by Butler Registry — do not edit
name: butler-registry-${operation}

on:
  workflow_dispatch:
    inputs:
      run_id:
        description: "Butler run ID"
        required: true
        default: "${runId}"

permissions:
  contents: read

jobs:
  butler-run:
    name: "Butler ${operation} — \${{ github.event.inputs.run_id }}"
    runs-on: ubuntu-latest
    timeout-minutes: 60
${envLines}
    steps:
      # ── Checkout ───────────────────────────────────────────────────
      - name: Checkout repository
        uses: actions/checkout@${ACTIONS_CHECKOUT_SHA} # v4.2.2
        with:
          repository: "${repoRef(repositoryUrl)}"
          ref: "${version}"
          fetch-depth: 1

      # ── Setup Terraform ────────────────────────────────────────────
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@${SETUP_TERRAFORM_SHA} # v3.1.2
        with:
          terraform_version: "${tfVersion}"
          terraform_wrapper: false

      # ── Pre-flight: check if run is cancelled ──────────────────────
      - name: Check run status
        env:
          RUN_ID: \${{ github.event.inputs.run_id }}
          BUTLER_CALLBACK_TOKEN: \${{ secrets.BUTLER_CALLBACK_TOKEN }}
        run: |
          STATUS=$(curl -sf -H "Authorization: Bearer $BUTLER_CALLBACK_TOKEN" \\
            "${callbackUrl}/v1/runs/$RUN_ID" | jq -r '.status // empty')
          if [ "$STATUS" = "cancelled" ]; then
            echo "::error::Run $RUN_ID has been cancelled — aborting."
            exit 1
          fi
          echo "Run status: $STATUS — proceeding."

      # ── Terraform Init ─────────────────────────────────────────────
      - name: Terraform Init
        working-directory: ${workDir}
        run: terraform init -input=false -no-color

      # ── Terraform ${capitalize(operation)} ─────────────────────────
      - name: Terraform ${capitalize(operation)}
        id: tf_operation
        working-directory: ${workDir}
        run: |
          set +e
          ${tfCommand} 2>&1 | tee /tmp/tf-output.log
          TF_EXIT=$?
          echo "tf_exit_code=$TF_EXIT" >> "$GITHUB_OUTPUT"
          exit 0
${postSteps}
      # ── POST status update ─────────────────────────────────────────
      - name: Report status to Butler
        if: always()
        env:
          RUN_ID: \${{ github.event.inputs.run_id }}
          BUTLER_CALLBACK_TOKEN: \${{ secrets.BUTLER_CALLBACK_TOKEN }}
          TF_EXIT_CODE: \${{ steps.tf_operation.outputs.tf_exit_code }}
        run: |
          if [ "$TF_EXIT_CODE" = "0" ]; then
            RESULT_STATUS="succeeded"
          else
            RESULT_STATUS="failed"
          fi

          PAYLOAD=$(jq -n \\
            --arg status "$RESULT_STATUS" \\
            --arg exitCode "$TF_EXIT_CODE" \\
            --arg operation "${operation}" \\
            '{status: $status, exit_code: ($exitCode | tonumber), operation: $operation}')

${buildPlanJsonUpload(operation)}
          curl -sf -X POST \\
            -H "Authorization: Bearer $BUTLER_CALLBACK_TOKEN" \\
            -H "Content-Type: application/json" \\
            -d "$PAYLOAD" \\
            "${callbackUrl}/v1/runs/$RUN_ID/status"

      # ── POST logs ──────────────────────────────────────────────────
      - name: Upload logs to Butler
        if: always()
        env:
          RUN_ID: \${{ github.event.inputs.run_id }}
          BUTLER_CALLBACK_TOKEN: \${{ secrets.BUTLER_CALLBACK_TOKEN }}
        run: |
          if [ -f /tmp/tf-output.log ]; then
            # Base64-encode the log to safely transport it in JSON
            LOG_B64=$(base64 -w0 /tmp/tf-output.log 2>/dev/null || base64 /tmp/tf-output.log)
            curl -sf -X POST \\
              -H "Authorization: Bearer $BUTLER_CALLBACK_TOKEN" \\
              -H "Content-Type: application/json" \\
              -d "$(jq -n --arg log "$LOG_B64" '{log: $log, encoding: "base64"}')" \\
              "${callbackUrl}/v1/runs/$RUN_ID/logs"
          fi
`;
}

/**
 * Extracts the owner/repo reference from a full repository URL.
 * Handles both HTTPS and SSH-style URLs.
 */
function repoRef(repositoryUrl: string): string {
  // https://github.com/org/repo.git -> org/repo
  // git@github.com:org/repo.git -> org/repo
  const match = repositoryUrl.match(/github\.com[/:]([^/]+\/[^/.]+)/);
  return match ? match[1] : repositoryUrl;
}

/**
 * Capitalizes the first letter of a string.
 */
function capitalize(s: string): string {
  return s.charAt(0).toUpperCase() + s.slice(1);
}

/**
 * Builds the YAML env block for the job from the envVars configuration.
 *
 * Secret-source vars use ${{ secrets.VAR_NAME }} syntax.
 * Literal values are injected directly.
 */
function buildEnvBlock(
  envVars?: Record<string, { source: string; ref?: string; key?: string; value?: string }>,
): string {
  if (!envVars || Object.keys(envVars).length === 0) {
    return '';
  }

  const lines: string[] = ['    env:'];
  for (const [varName, varConfig] of Object.entries(envVars)) {
    if (varConfig.source === 'secret') {
      // Use GitHub Actions secret reference (K8s Secret pattern)
      const secretName = varConfig.key || varName;
      lines.push(`      ${varName}: \${{ secrets.${secretName} }}`);
    } else if (varConfig.source === 'ci_secret') {
      // CI-native secret reference
      const secretName = (varConfig as any).name || varName;
      lines.push(`      ${varName}: \${{ secrets.${secretName} }}`);
    } else if (varConfig.source === 'literal' && varConfig.value !== undefined) {
      // Inject literal value directly
      lines.push(`      ${varName}: "${escapeYamlString(varConfig.value)}"`);
    }
  }
  return lines.join('\n');
}

/**
 * Builds the terraform command string and any post-operation steps based on operation type.
 *
 * The returned tfCommand is embedded into the main run step which already handles:
 *   set +e / tee / TF_EXIT / GITHUB_OUTPUT
 *
 * postSteps are additional YAML step blocks inserted after the operation step.
 */
function buildTerraformCommand(
  operation: string,
  workDir: string,
): {
  tfCommand: string;
  postSteps: string;
} {
  switch (operation) {
    case 'plan':
      return {
        tfCommand: 'terraform plan -input=false -no-color -out=tfplan -json',
        postSteps:
          '\n      # ── Export plan JSON ─────────────────────────────────────────\n' +
          '      - name: Export plan JSON\n' +
          '        if: always()\n' +
          `        working-directory: ${workDir}\n` +
          '        run: |\n' +
          '          if [ -f tfplan ]; then\n' +
          '            terraform show -json tfplan > /tmp/tf-plan.json 2>/dev/null\n' +
          '          fi\n',
      };
    case 'apply':
      return {
        tfCommand: 'terraform apply -input=false -no-color -auto-approve tfplan',
        postSteps: '',
      };
    case 'validate':
      return {
        tfCommand: 'terraform validate -no-color -json',
        postSteps: '',
      };
    case 'test':
      return {
        tfCommand: 'terraform test -no-color -json',
        postSteps:
          '\n      # ── Capture test results ──────────────────────────────────────\n' +
          '      - name: Capture test results\n' +
          '        if: always()\n' +
          `        working-directory: ${workDir}\n` +
          '        run: |\n' +
          '          if [ -f /tmp/tf-output.log ]; then\n' +
          '            cp /tmp/tf-output.log /tmp/tf-test-results.json\n' +
          '          fi\n',
      };
    case 'destroy':
      return {
        tfCommand: 'terraform destroy -input=false -no-color -auto-approve',
        postSteps: '',
      };
    default:
      return {
        tfCommand: `terraform ${operation} -input=false -no-color`,
        postSteps: '',
      };
  }
}

/**
 * For plan operations, adds a step to upload the plan JSON to the callback.
 */
function buildPlanJsonUpload(operation: string): string {
  if (operation !== 'plan') {
    return '';
  }

  return `          # Attach plan JSON if available
          if [ -f /tmp/tf-plan.json ]; then
            PLAN_B64=$(base64 -w0 /tmp/tf-plan.json 2>/dev/null || base64 /tmp/tf-plan.json)
            PAYLOAD=$(echo "$PAYLOAD" | jq --arg plan "$PLAN_B64" '. + {plan_json: $plan, plan_encoding: "base64"}')
          fi

`;
}

/**
 * Escapes special characters for safe YAML string embedding.
 */
function escapeYamlString(s: string): string {
  return s
    .replace(/\\/g, '\\\\')
    .replace(/"/g, '\\"')
    .replace(/\n/g, '\\n');
}
